# 硅基计划2.0 学习总结 柒 接口与内部类以及String类

***
![1750851495539](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202507112355473.jpg)
***

## 一. 接口

### 1. 对象比较——传统型

```java
//Test类
public static void main(String[] args) {
        Person person1 = new Person(15,"张三");
        Person person2 = new Person(12,"李四");

        if(person1 > person2){
            System.out.println("person1>person2");
        }
    }
//Person类
public class Person {
    private int age;
    private String name;

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }
}
```
两个类之间是不能直接通过`><=`进行比较的，因为你并未说明任何比较的规则，你心里想的肯定认为是两个对象引用去比较地址，其实不然，要想比较特定规则，我们就要去通过`comparable<类名>`这个接口去实现  
我们打开`comparable`的源码发现内部有`camparaTo`方法需要我们去重写我们的比较规则，比如我们去重写年龄的比较规则  
我们观察到`comparaTo`方法的返回值是int类型，则我们按照从小到大排序就是  

```java
@Override
    public int compareTo(Person o) {
        if(this.age >o.age){
            return 1;
        }else if(this.age == o.age){
            return 0;
        }else{
            return -1;
        }
        //简化：return this.age-o.age;
    }
```
我们知道在类中this指向当前对象，那么这里的this指的就是调用这个方法的对象，我们以person1为例，我们通过person1调用这个方法，那么这个方法的this就指向了person1这个对象  
因此我们针对年龄规则比较大小就可以在main方法中通过`int ret = person1.compareTo(person2);`去调用，再把另外一个对象传参传过去，通过返回值判断两个对象的大小   

```java
if(ret > 0){
            System.out.println("person1>person2");
        }
```

### 2. 对象比较——灵活型

不知你是否想过，嗯，我今天用了年龄这个规则比较，但是明天我又想用姓名这个字符串进行比较，是不是又要改写代码，那之前的比较规则的代码就作废呢  
这样未必也太死板了吧，确实，接下来我们通过中间类实现接口去灵活比较  
接下来我们专门创建一个用于名字比较规则的类`Namecomparator`
实现`Comparator<Person>`接口，我们点开String类，可以清晰的看到有个comparable接口，可知其内部必有comparaTo方法，因此我们在`Namecomparator`类中重写compara方法  

![image-20250711145344360](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202507111453518.png)

重写后的代码如下，我们再去实例化这个比较起类的对象，直接调用comparaTo方法即可  
```java
public class Namecomparator implements Comparator <Person>{
    @Override
    public int compare(Person o1, Person o2) {
        return o1.name.compareTo(o2.name);
    }
}

public static void main(String[] args) {
Namecomparator namecomparator = new Namecomparator();
        int rets = namecomparator.compare(person1,person2);
        if(rets>0){
            System.out.println("person1>person2");
        }
}
```
这样既不用担心一个规则写死类，也提高了代码的灵活型

### 3.对象数组排序  
此时我让Person类去掉实现comparable接口，我创建了一个对象数组，我通过Person类创建了三个对象，然后我让对象数组的三个下标分别引用这三个对象  
我想通过数组的`sort`把我的三个对象排个序，但是编译时产生异常，提示没有任何排序规则  
![image-20250711152922447](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202507111529190.png)
此时就要我们去实现comparable接口了，重写comparaTo方法，我们以年龄为例，还是之前那一套逻辑，我们再打印下，发现其能够正常排序了  
![image-20250711153922608](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202507111539739.png)
因此我们要有意识，以后我们的自定义类型要实现比较类型的接口、toString、equals、hascode等，点开`Arrays.sort()`的源码我们得知其传参还是传了比较器  
还记得之前的`Namecomparator`的对象`namecomarator`吗，因此我们传参还可以传入比较器规则`Arrays.sort(person,namecomparator);`这样就可以根据我们自己写的规则去排序了，非常方便  

### 4. 自定义冒泡排序并通过数组传参  
我们要先定义一个类的多个对象，并保证这些对象均实现类comparable接口并在那个类中重写comparaTo方法，我重写后是按照年龄大小进行比较的  
因此我们自定义冒泡排序的时候通过接口数组传的参数排序规则就是我这个comparaTo的排序规则，内部交换的时候要定定义一个临时变量，就跟之前交换数字一样  
```java
//Person类中
public class Person implements Comparable<Person>{
    protected int age;
    protected String name;

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public int compareTo(Person o) {
        return this.age - o.age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}
//Test类中
public class Test {
    public static void bubbleSort(Comparable [] comparables){
        for (int i = 0; i < comparables.length-1; i++) {
            for (int j = i; j <comparables.length-1-i; j++) {
                //判断交换
                if(comparables[j].compareTo(comparables[j+1])>0){
                    Comparable comparable = comparables[j];
                    comparables[j] = comparables [j+1];
                    comparables [j+1] = comparable;
                }
            }
        }
    }

    public static void main(String[] args) {
        Person person1 = new Person(15,"abc");
        Person person2 = new Person(18,"efg");
        Person person3 = new Person(20,"hjk");
        Person [] people = new Person[3];
        people[0] = person1;
        people[1] = person2;
        people[2] = person3;
        bubbleSort(people);
        System.out.println(Arrays.toString(people));
    }
}
```

### 5. 克隆接口  
```java
public class Person {
    public int age;

    public Person(int age) {
        this.age = age;
    }
}
```
现在我通过Person创建了一个对象person1，然后我想把对象person1克隆一份，然后我通过`Person person2 = person1.clone();`无反应，我们知道其父类是Object类，被protected修饰类，而object类在其他包中，因此我们不能直接访问，但是我们可以在其子类Person类中进行重写
```java
@Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
```
但是此时还是爆红，提示要先处理异常，Java为了安全性要先处理异常，因此我们在main方法后抛出异常`public static void main(String[] args) throws CloneNotSupportedException`，但是此时还是不行，因为clone方法是父类的，类型要为object，因此我们要强转为子类再进行克隆，因此
```java
public static void main(String[] args) throws CloneNotSupportedException {
        Person person1 = new Person(10);
        Person person2 = (Person) person1.clone();
    }
```
但是此时此时还是提示报错，内容是克隆不允许，此时我们仅仅需要实现一个克隆接口`Cloneable`就不会报错了，打开这个接口我们发现是一个空接口，说明这种类型的接口就是标记用的，告诉编译器我需要克隆这个类对象`public class Person implements Cloneable`  
![image-20250711160034076](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202507111600097.png)

### 6. 深拷贝与浅拷贝  
所谓浅拷贝，就是对象在拷贝的时候，对象是拷贝类，可是对象所持有的内部资源却并没有拷贝  
就拿刚刚的Person举例，我们再定义一个身高类，我们在Person类中实例化这个High类，创建一个对象，假设我们创建了一个叫high的对象，我们让其为10  
所谓浅拷贝，就是你Person类的对象是拷贝类，假设我们拷贝了个person2来，person1与person2是不同的地址  
但是person1和person2中的high却是同一个对象，都指向了person1中的high，当你通过person2去改变high的值，你的person1中的high值也会改  
如下我们在Person类中实现克隆接口，再在main方法中抛出异常  
```java
//Test类
public static void main(String[] args) throws CloneNotSupportedException {
        Person person1 = new Person(15,"abc");
        Person person2 = (Person) person1.clone();
        System.out.println(person1.highs.high);
        System.out.println(person2.highs.high);
        person2.highs.high = 180.0;
        System.out.println(person1.highs.high);
        System.out.println("我们不难发现上面的high是一样的，而且person2改动person1也会变");
    }
//Person类
public class Person implements Cloneable{
    protected int age;
    protected String name;

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }

    High highs = new High(175.0);

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
//High类
public class High {
    protected double high;

    public High(double high) {
        this.high = high;
    }
}
```
这样就是浅拷贝，每个对象改动其highs的对象中的high都会改的  
因此我们要实现深拷贝，观察Person类中的克隆方法，我们不难发现其返回值给了另一个对象，说白了就是person1返回值给了person2，因此我们可以定义临时对象

```java
@Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
//因此我们重写如下
@Override
    protected Object clone() throws CloneNotSupportedException {
        Person temp = (Person) super.clone();//Person类中克隆了的对象传进来
        temp.highs = (High) this.highs.clone();//再强转为克隆的对象
        return temp;
    }
```
这样你再去改动另一个对象的high就不会影响到另一个对象了，它们是相互独立了，具体原理我之前博客有介绍，这里贴上链接[LINK](https://blog.csdn.net/Pluchon/article/details/148150008?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223d33af63f038e038060eb93527e8638a%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=3d33af63f038e038060eb93527e8638a&biz_id=0&spm=1018.2226.3001.4450)

## 二、内部类  
内部类说白了就是在类中再定义一个类，什么时候去使用，就是在外部类中你想细分一个类去描述大类的某个具体细节，就跟火车车厢一样，火车是大类，每一节车厢就是一个内部类  
### 1. 静态内部类  
就是在class前加入static修饰符，我们知道静态类不依赖于对象创建  
因此在获取内部类对象的时候我们要通过外部类作为桥梁去访问内部类，就跟访问静态成员一样，此时再通过这个对象去访问静态类内部成员  
跟静态成员变量一样，在静态内部类中不可以直接访问外部类的非静态成员变量，如果飞扬访问则需要在静态内部类中new一个外部类对象才行，具体代码如下：  
```java
public class Test {
    private int age = 8;
    public double high;
    static int month;

    static class InnerA{
        private String name = "ss";
        public double weight;

        Test test = new Test();
        
        void S(){
            System.out.println(test.age);
        }
    }

    public static void main(String[] args) {
        Test.InnerA a = new Test.InnerA();
    }
}
```
并且其生成的字节码文件都是`外部类名$内部类名.class`  

### 2. 实例内部类  
去掉static修饰，说白了就是要实例化对象去访问类，因此在创建实例化内部类的对象的时候，需要外部类对象为前提去实例化内部类对象`Test test = new Test();Test.InnerB b = test.new InnerB();//也可以写为new Test().new InnerB();`  
并且由于你是实例内部类，有对象为前提，因此内外部类的所有成员变量你都可以访问  
但是若内外部类存在同名的成员变量，即使你想到用this但是这个this指向的是调用放也就是内部类，因此我们需要通过`外部类类名.this 重名变量`去访问外部类的重名变量  
说白了就是实例内部类的非静态方法包含了一个指向外部类对象的引用，但是这个在静态类内部不可用  
同时外部类也不可以直接访问实例内部类成员，遵循先有对象原则，当然各个成员变量也可以加上修饰限定符  

### 3. 局部内部类  
定义在方法体中，作用域只有在方法体内，且不能有修饰限定符，字节码文件是`外部类$数字内部类.class`  

### 4. 匿名内部类  
说白了就是没有名字的类，比如实现接口这样  
```java
    interface Ss{
        void abc();
    }
    
    public static void main(String[] args) throws CloneNotSupportedException {
        Ss ss = new Ss(){//因为是接口类实现，我们可以直接这样子new一个对象
            @Override
            public void abc(){
                System.out.println("abc");
            }
        };
        ss.abc();//通过对象访问成员方法
```

#### 补充：在编译器左边方法中，画横线是过时方法可以用不推荐，锁起来的是不可以直接使用的，没锁起来的是可以直接用的

## 三、字符串常量池  
虽然在Java官方没有明确定义，但是在JVM中是以StringTable的哈希表存在，我们写的字符串常量会存在里面，“池”能够提升效率  
你可以认为它是一张银行卡，钱存里面想用就拿不用就放那，因此有了“池”我们原本池里有的就不用再创建了，不必每次再开辟空间  
### 1. 使用  
```java
public static void main(String[] args) {
        String str1 = "sss";
        String str2 = "sss";
        System.out.println(str1 == str2);
    }
```
结果显而易见是true，此时内存池的操作是创建完str1对象后，发现池没有"sss"  
那就放入池中，创建str2对象时，看看其内容是否在池中已存在，发现存在了，直接让str2引用str1所指向的对象，无需重新创建  
```java
public static void main(String[] args) {
       String str3 = new String("aaa");
        String str4 = new String("aaa");
        System.out.println(str3 == str4);
    }
```
虽然结果是true，但也只是代表两个String类的对象地址不一样，其对象内部还是指向内存池中同一个字符串"aaa"，因此此时"aaa"还是只有一份，具体如下图  
![image-20250711164844996](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202507111648070.png)

### 2. 举一反三
1. 就比如字符串相等的equals方法，在String类中是重写了其父类Object的方法的，在父类中的equals是比较地址的  
2. 在String中也可以用comparTo比较大小，返回类型是int类型，比如“ccc”就比“abb”大
3. 忽略大小比较，会用到`ComparaToIgnoreCase`这个类去比较，比如“ABC”和“abc”比较结果一样  

***
![图 (444)](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202507111850879.jpg)
***

## 四、String类  
### 1. 字符串查找方法——char charAt  
返回的是下标对应的字符，通过char类型接收，比如如下代码，打印的结果就是“l”，你也可以通过循环遍历字符串，但是需要注意**如果为负数或者是越界则会抛出异常**  
```java
public static void main(String[] args) {
        String str1 = "hello world";
        char ret = str1.charAt(2);
        System.out.println(ret);
    }
    
//遍历字符串
for (int i = 0; i < str1.length(); i++) {
            System.out.print(str1.charAt(i));
        }
```

### 2. 字符串查找方法——int indexOf/int lastIndexOf  
比如我们可以查找指定字符或字符串的位置：`int ret = str1.indexOf('e');`  
或者是不从开头找，从指定位置（假设下标为2）找：`int ret2 = str1.indexOf('o',2);`  
又或者是查找指定字符串，返回的是查找字符串的第一个字符的下标：`int ret3 = str1.indexOf("world");`  
也可以指定位置开始找：`int ret4 = str1.indexOf("world",5);`  
同理`lastIndexOf`跟这些一模一样，只不过是倒着找而已  

### 3. 字符串转换方法——其他类型转字符串  
比如`String valueOf(123)`可以转变成`"123"`，
当然，也可以把对象转变成字符串,先在Person类中重写toString方法，在=再`String str = String.valueOf(new Person(12,"张三"));`  

### 4. 字符串转换方法——字符串转其他类型  
比如我们可以把字符串数字转整型数字，还有很多方法等等  
```java
String str = "123";
        int ret = Integer.parseInt(str);
        double rets = Double.parseDouble(str);
```

### 5. 字符串转换方法叁——大小写转换  
小写转大写，我们可以用`toUpperCase`，用String去接收，但是并不只直接修改原变量的值，而是new了一个新对象，这个新对象把旧对象的内容都大写了，同理大写转小写`toLowerCase`  

### 6. 字符串转换方法——字符串转数组  
比如转换成char数组我们要用到`toCharArray`，返回类型是一个char类型数组，反之数组也可以转字符串，像我们之前很熟悉的`String s = new String(str)//str是你要转换的数组名`  

### 7. 字符串转换方法——数据以格式化生成到字符串中  
要用到`format`方法，比如要把年月日转换成`yyyy-mm-dd`格式，则我们可以用`String str = String.format("%d-%d-%d",2025,7,11);`  

### 8. 字符串转换方法——替换  
要用到`replace`方法，比如我们把hello world单词中o替换成s，则可以`String ret1 = str1.replace('o','s');`，还可以替换字符串，替换的内容可以比原来长或者短`String ret2 = str1.replace("ll","sssss");`，同理还有其他类似的比如`replaceAll`就是所有替换，`replaceFist`就是把第一个替换了  

### 9. 字符串转换方法——拆分  
利用`split`方法，返回的类型是一个数组，比如刚刚的hello world，如果以空格拆分，就可以得到两个元素`String [] rets = str1.split(" ");`，而结果就是[hello, world]  
`String [] ret3 = str2.split(" ",2);`，也可以指定分几组，比如以空格分隔符分割"s s s s"分两组，则第一个空格分割后第二个空格不用再分了因为结果已经是两组了，结果就是[a, b c d e]  
如果你想以多个分隔符分割，则中间用“|”连接就好  
但是特殊的，比如以“.”分割，需要打上转义字符“\\.”，第一个斜杠是明确特殊字符表示，第二个则是想转义的字符的修饰，若要转义斜杠，则要四个斜杠  
不仅如此我们还可以多层拆分，即最开始先拆什么，每个拆开的小部分内部又拆开什么，如下
```java
public static void main(String[] args) {
        String str = "abc=bbc,hjk=xyz";
        String [] ret = str.split(",");
        for(String rets : ret){
            String [] retss = rets.split("=");
            for (String retsss :retss){
                System.out.println(retsss);
            }
        }
    }
//结果就是分成四部分了：abc bbc hjk xyz
```

### 10. 字符串转换方法——截取  
要用到方法`subString`，从哪个下标开始截取，返回的是一个字符串，内容是从下标开始后面的字符串内容，当然也可以局部截取，遵循左闭右开区间，一般Java中范围都是这样  
```java
String str = "hello world";
        String ret = str.substring(5);
        String rets = str.substring(1,5);
```

### 11. 字符串转换方法——去除空格  
要用到方法`trim`，但是只能去掉两边的空格  

### 12. 字符串转换方法——手动加入常量池  
要用到`intern`方法，此时我下面代码的判断str1与str2就为true，因为str1所指的对象在常量池中没有，因此放入，此时str2的字符串为str1中已经有的了，因此str2引用了常量池中str1存入的字符串“abc”，因此它们的地址（str1与str2）就相同了  
```java
public static void main(String[] args) {
        char [] chs = new char[]{'a','b','c','d'};
        String str1 = new String(chs);
        s1.intern();
        String str2 = "abc";
        System.out.println(str1 == str2);
    }
```

### 13. 字符串转换方法——打印地址  
要用到整型中的方法，为`Integer.toHexString(System.identityHashCode(s1));``Integer.toHexString(System.identityHashCode(s2));`

### 14. 字符串不可变性  
之前已经提到过，我们任何方法都不是改变原有字符串，都是创建了一个新的对象，String内部都被private修饰，而final知识说明只能指向当前对象，但是可以另辟蹊径通过反射去弄  
如果你通过循环不断的去“修改”，会产生很多临时对象，效率降低  

### 15. StringBuffer和StringBulider  
两个类很相似，其源码都被final修饰，利用这个类去拼接效率就会高很多，比如  
```java
StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("abc").append("def");
        stringBuilder.append("ssss");
```
打印的结果就是各个字符串拼接的结果，当然`StringBuffer`也一样结果，但是它们的区别就是`StringBuffer`中被`synchronized`修饰，即在多线程条件下更安全，就好比房间上锁，但是这样也会消耗更多资源，效率又下降了  

## 五、异常浅述（Exception）

异常就是程序正常执行被阻断了，要特别处理，分为编译时（受查）异常和非编译时（非受查）异常，比如算数异常中除0问题，空指针等等  
查阅资料发现异常与错误共属于`Throwable`的子类（语法错误不是），此时JVM虚拟机无法解决，比如无限递归导致的栈溢出问题等等  

***
## 六、练习

### 1. 字符串中唯一字符

[链接](https://leetcode.cn/problems/first-unique-character-in-a-string/description/)，先字符串转数组，我们思路就是先遍历字符串中的每个字符  
再去用对应的Arrays数组去接收然后去计数，最后再编译一遍字符串，看看每个字符出现了几次，即哈希思想  
```java
int [] count = new int[130];
for(int i = 0;i<s.length;i++){
 char ch = s.charAt(i);//每次循环创建一个字符数组，再把原字符串中对应下标的字符取出来
 count ['ch']++;//之后再根据其ASCII码值存入对应下标，达到计数效果
}
for(int i =0;i<s.length();i++){//此时再去遍历原来的字符串
 char ch = s.charAt(i);//再通过穿件字符数组来取出原字符串每个下标对应的字符
 if(count [ch] == 1){//让取出的字符与count数组中的计数比较，返回第一个出现1的字符
  return i;
 }
}
//优化，减少数组空间开销：
count[ch-97]++;
if(count[ch-97] == 1)
```

### 2. 验证回文字符串  
[链接](https://leetcode.cn/problems/valid-palindrome/description/)，核心思想就是双指针，一个从头开始遍历，往后走，一个从末尾开始遍历，往前走，左右下标如果遇到不是字母数字是就继续走，走到字母数字就停下来  
```java
s = s.toLowerCase();//先把大写字母全部转成小写
int i = 0;
int j = s.length()-1;
while(i<j){//如果第一轮首尾字母就不相等，后面就不用判断了，直接返回false，否则继续判断
 while(i<j&&isMumberorCharacter(s.charAt(i))){
  i++
 }
 while(i<j&&isMuberorCharacter(s.charAt(j))){
  j--;
 }
 if(s.charAt(i) != s.charAt(j)){
  return false;
 }
 i++;
 j--;
}
return true;
}

private boolean isMumserorCharacter(char ch){//用于判断是否是数字或者是字母
 if(Character.isDigit(ch)||Character.isLetter(char)){
  return true;
 }
 return false;
}
```

### 3. 字符串最后一个单词的长度  
[链接](https://www.nowcoder.com/practice/8c949ea5f36f422594b306a2300315da?tpId=37&&tqId=21224&rp=5&ru=/activity/oj&qru=/ta/huawei/question-ranking)，先处理循环输入，在实现核心思想`Scanner sc = new Scanner(System.in);while(sc.hasNext()){}`，核心思想就是有很多种，可以找到最后一个空格，从其下一个位子开始，截取字符串再计算长度即可  

```java
int length = s.length();
String str = s.substring(s.indexOf(" ")+1,length);//左闭右开区间
int ret = str.length();
System.out.println(ret);
```

***
<center>文章难免会有错误，期待您的指正，我们共同进步</center>
***
<div align = center>
<a href = https://gitee.com/pluchon/java-career/tree/master/TestProject20250711/src >Git码云仓库链接一号</a>
<a href = https://gitee.com/pluchon/java-career/tree/master/TestProjectAgain20250711/src>Git码云仓库链接二号</a>
<div>

***
<center>END</center>