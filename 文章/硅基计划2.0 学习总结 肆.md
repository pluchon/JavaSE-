![图 (907)](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505252121132.jpg)  
[toc]  
***

## 1. 二维数组补充

* 在创建数组的时候，你new一个对象，要明确行和列，每一行可以用“{}”区分  
> ```Java
> int [] [] array = new int [][]{{1,2,3},{4,5,6}};
> ```
> 当然写的时候你也可以明确行和列
> ```Java
> int [] [] array = new int [2][3];
> ```

### 1. 是特殊一维数组

> ![image-20250525212925598](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505252129669.png) 
> 我们从图中就可以看到，二位数组中的每一个元素本质上都为一个个一维数组  
> ___即存的地址，这个地址指向其所指向的一维数组对象___  

### 2. 求数组长度  
> 1. `array.length`求的是二维数组的行数，通过我们刚刚画图  
> 我们可以知道，二维数组你可以把它看为特殊的一维数组  
> 求长度不就是求**有多少个一维数组**嘛  
> 2. `array[i].length`求的是第i行有多少个元素，即列数  
> 即二维数组中每一个一维数组所指向的对象的数组的长度（抽象成二维数组列数）  

### 3. 遍历  
> ```Java
> public static void main(String[] args) {
>         int [] [] array = new int [] []{{1,2,3},{4,5,6}};
>         for(int [] tmp:array){
>             for(int x:tmp){
>                 System.out.print(x+" ");
>             }
>             System.out.println();
>         }
>     }
> ```
> 
> * 为什么有两层循环遍历呢，因为**二位数组本质是一个个一维数组**  
> 因此我们先要把二维数组（看成一维数组前提下）每一个元素取出来  
> 因此我们就要用`int [] tmp`数组类型来接收  
> 接收后我们就要接着循环打印每一个一维数组  
> 就正常给一个变量接收每一个一位数组中的每一个元素  

### 4. toString和ddeepToString  
> 如果你使用toString去转换数组，打印的结果只会是二维数组中每一个一维数组地址  
> 而使用ddeepToString才会打印整个数组内容  
> ![image-20250525215301829](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505252153886.png)  

### 5. 默认值  
> ```Java
> int [] [] array = new int [2] [];//行必写，列可省
> System.out.println(Arrays.toString(array1));
> ```
> 
> 打印的结果是两个null，即没有指向任何对象，因为数组是引用数据类型  
> 若你单独给每一行初始化  
> ```Java
> array1[0] = new int [3];
> array1[1] = new int [3];
> System.out.println(Arrays.deepToString(array1));
> ```
> 
> 打印的结果就是全是0，说明给每一行创建对象后  
> 二维数组中每一个元素都有其指向的一维数组的对象，默认初始化就是0了  

***
## 2. 类和对象  
### 1. 定义类（class）  
> 1. 格式：`class （类名） {......}` ，“{}”中写类的成员变量（属性）和成员方法  
> > 这里有几个注意事项：  
> > 1. 区分下成员变量和局部变量：成员变量在类中但在方法之外，局部变量在方法内  
> > 2. 这边建议一个类放在一个Java文件中（一个类对应一个字节码文件class）  
> > 3. 类的命名采用大驼峰（每个单词首字母大写）  
> > 4. 成员变量和成员方法都分为静态（static修饰）和非静态  
> > 5. 如果使用Idea编译器，在当前类中定义了其他类，会有警告，此时我们可以剪切代码，剪切后直接点击SRC文件然后ctrl+粘贴，自动生成了一个以你剪切的这个类名的Java文件  
> > 6. 如果你想修改类名，不能直接在代码中修改，通过Idea编译器选择对应Java文件重命名，重命名之后，其他类中有你当前这个类的类名也会跟着改变  
> 
> 以下是示例代码，定义了一个学生的类  
> ```Java
> public class Student {
>         public int age;
>         public int high;
>         public String name;
> 
>         public void print(){
>             System.out.println(age+" "+high+" "+name);
>         }
>     }
> ```

### 2. 实例化类  
在main方法中，通过`new`关键字来创建对象，而且可以new多个对象  
> ```Java
> Student stu1 = new Student();
> Student stu2 = new Student();
> Student stu3 = new Student();
> ```
> 其中Student相当于类型（类比i`int a = 10;`），stu1相当于对象名称  

### 3. 使用对象  
1. 究竟new了什么  
* 我们画个图来讲解  
![image-20250526100757180](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505261007269.png)  

2. 访问和修改属性  
> 对于类中成员变量，我们可以通过`对象名.属性`访问活修改，进而可以给多个对象中的成员变量赋值  
> `stu1.age = 18`，`stu2.age = 19`，`stu3.age = 20;`  
> 并且不同对象在堆中的位置都不一样，因此每个对象中同一个成员变量的值可能不同  

3. 访问成员方法  
* 格式：`对象名.方法名();`

> 补充：可以双击shift查看这个类中有哪些成员变量  
> ![image-20250526121253870](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505261212968.png)

## 3. this关键字

1. 写一个方法给成员变量赋值  
> ```Java
> public void setStudent(int a,int h,String n){
>             age = a;
>             high = h;
>             name = n;
> }
> //赋值成功后我们在main方法中再调用setStudent方法，再传值，再看结果  
> Student stu1 = new Student();
> stu1.setStudent(19,180,"zlh");
> stu1.print();
> ```
>
> ![image-20250526102213395](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505261022449.png)  

* [ ] 但是你这么想，我有那么多对象，而你只有一个类，怎么对这些对象做区分呢，我每一个对象都赋予不同的值，编译器是如何区分不同对象的呢？  

2. this关键字应用场景  
* [ ] 当你把形参名改成和成员变量名一致的时候  
> ```Java
> public void setStudent(int age,int high,String name){
>             age = age;
>             high = high;
>             name = name;
> }
> ```
> 
> * 此时你再传值的时候，你会发现调用print方法打印结果都变成0了，为什么？而且在类中编译器也会爆出警告，形参自己给自己赋值了  
> ![image-20250526102852352](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505261028436.png)  
> * 如果此时你添加this关键字指向当前对象中的age，high，name的值，就正常了  
> ```Java
> public void setStudent(int age,int high,String name){
            this.age = age;
            this.high = high;
            this.name = name;
> }
> ```
> ![image-20250526102213395](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505261022449.png)  
> 因此我们得以知道，this关键字作用就是**每次对象调用的时候通过this来指向当前调用的对象**  
> 进而我们知道了当多个对象调用一个方法的时候（比如setStudent），this就看谁调用了这个方法，那我就指向谁，就给哪个对象赋值  
> 因此其实在setStudent中有一个隐藏的参数`setStudent(Student this,......)  

3. 调用当前对象中成员方法  
> ```Java
> public void setStudent(Student this,int age,int high,String name){
>             this.age = age;
>             this.high = high;
>             this.name = name;
>             this.print();
>         }
> 
>     public void print() {
>         System.out.println(age + " " + high + " " + name);
> }
> //在main方法中无需再调用对象stu1的print成员方法了
> Student stu1 = new Student();
> stu1.setStudent(19,180,"zlh");
> ```
> ![image-20250526102213395](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505261022449.png)  

## 4. 交换变量值  
> 核心思想就是利用this关键字在调用类的时候指向调用类的对象（通常是不同的）来达到交换目的  
> ```Java
> public static void swap (MyValue myValue1,MyValue myValue2){
> int tmp = myValue1.val;
> myValue1.val = myValue2.val;
> myValue2.val = tmp;
> }//此时的myValue1中存的是其对象地址，myValue2也是存的其对象地址，前面都是类的类型
>
> MyValue myValue1 = new MyValue();
> myValue1.val = 10;
> MyValue myValue2 = new MyValue();
> myValue2.val = 20;
> System.out.println();
> System.out.println("调换前："+myValue1.val+" "+myValue2.val);
> System.out.println("---------------");
> swap(myValue1,myValue2);//传两个对象，即引用传值
> System.out.println("调换后："+myValue1.val+" "+myValue2.val);
> 
> //MyValue方法中
> public class MyValue {
>     public int val;
> }
> ```
> 
> ![image-20250526110533287](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505261105367.png)  

## 5. 就地/默认初始化  
>成员变量中不给初始值，其成员变量也会存在默认值，引用类型为null，布尔类型为flase  

### 1. 就地初始化  
指的是在创建成员变量的时候直接赋值`public int age = 18;`，即默认初始值，后续可以再改变值  
只不过不能在成员变量中改变了`public int age = 18; age = 20;`是不可以的  

### 2. 构造方法初始化  
> 它是特殊的方法，**无返回值且与类名相同**，分为带参数和不带参数，其目的就为了初始化成员变量，本质上是方法的重载  

> 1. 这个是无参构造方法  
> ```Java
> public Student(){
>   this.age = 18;
>   this.high = 180;
>   this.name = "zlh";
> }
> ```
> 2. 这个是有参构造方法  
> ```Java
> public Student (int age,int high,String name ){
>  this.age = age;
>  this.high = high;
>  this.name = name;
> }
> ```

### 3. 调用构造方法  
> 何时调用：**在实例化对象的时候调用**
> ```Java
> Student stu1 = new Student(19,180,"zlh");
> ```
> 你在new对象的时候给了什么样的参数（或者不给参数），就会调用对应参数列表的对应构造方法  

> 本质上一个对象的产生：为对象分配内存-->调用合适的构造方法  

> 两种构造方法都可以并存，但是有几点要注意：  
> 1. 如果类中不存在构造方法，Java会给默认的无参构造方法  
> 2. 若已经有一个构造方法了（假设是有参），此时你类创建对象的时候你再调用无参构造方法会报错，因为编译器认为你已经有一个构造方法了，无需再提供无参构造方法，因此只有在无构造方法前提下不写无参构造方法编译器才会给你在new过程中默认提供无参构造方法  
> 3. 构造方法在对象创建中只会调用一次，构造方法可以重载（多个）  

### 4. 嵌套调用  
可以使用`this()`，括号中填写你想调用的那个构造方法的参数列表  
比如你可以写`this(18,180,"zlh")`来调用`public Student (int age,int high,String name )`这个构造方法  
> 注意：
> 1. 此时你已经调用了其他构造方法，在其他构造方法中执行完流程后，会回到当前构造方法，执行下一行代码  
> 2. 调用其他构造方法的时候，必须把`this()`写在当前构造方法的第一张，否则报错  
> 3. （假设当前是A构造方法）不能调用了B构造方法，再在B中调用A构造方法（调回来），不能形成环  

### 5. 对象的打印  
> 不觉得每次类中都要写print成员方法打印类的成员变量很麻烦吗，Java中提供便利  
> ![image-20250526113933757](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505261139837.png)
> 生成了如下代码：
> ```Java
> @Override
>     public String toString() {
>         return "Student{" +
>                 "age=" + age +
>                 ", high=" + high +
>                 ", name='" + name + '\'' +
>                 '}';
> }
> //在main方法中可以直接打印
> System.out.println(stu1);
> ```
> 打印结果是：Student{age=19, high=180, name='zlh'}，还可以自定义打印格式  

> 我们看到借助println打印，我们点开println内部看看  
> ```Java
> public void println(Object x) {
>         String s = String.valueOf(x);
>         if (getClass() == PrintStream.class) {
>             // need to apply String.valueOf again since first invocation
>             // might return null
>             writeln(String.valueOf(s));
>         } else {
>             synchronized (this) {
>                 print(s);
>                 newLine();
>             }
>         }
>     }
> ```
> 我们看到是调用了一个valueOf方法，我们再点开看  
> ```Java
> public static String valueOf(Object obj) {
>         return (obj == null) ? "null" : obj.toString();
>      }
> ```
> 我们可以看到在三元判别式中又调用了一个toString方法，我们再点开看  
> ```Java
> public String toString() {
>         return getClass().getName() + "@" + Integer.toHexString(hashCode());
>     }
> ```
> 这个打印格式是不是很熟悉`Student{age=19, high=180, name='zlh'}`  
> getClass对应类名，后面对应的是成员变量名，我目前只是水平只能解释到这里  
> 而且如果你没有在类中写toString，则会打印对象地址，否则就执行你的toString方法

## 6. 其他注意要点

1. `Student stu1 = null;`表示p不指向任何对象，而不是空对象，空对象也可能是个对象  
2. ___一个对象可以被多个引用指向，而一个引用只能指向一个对象___  

***
![图 (883)](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505271037974.jpg)
***

## 7. 包的定义

### 1. 包是什么  
> * 包是Java中组织类的一个方式  
> * 你可以把它理解成一个工具包，这个工具包里面有很多类，每个类又有很多功能  
> * [ ] 意义：提高代码可读性，防止类同名导致的冲突，是一种类接口的封装与组织  
> 一个类可能有多个包与之对应，比如Date类  
> ![image-20250527080505397](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270805499.png)
> 如图所见Date类在util包和sql包中都有对应，这时候就要用包定义做区分，选择对应的包然后回车导入即可  

### 2. 导包通配符（不建议）  
> 当使用同一个包下的多个方法时，每次导包太麻烦也太重复了，可以使用通配符“*”  
> ```Java
> //import java.util.Arrays;
> //import java.util.Scanner;
> import java.util.*;
> public static void main(String[] args) {
>         Scanner sc = new Scanner(System.in);
>         int [] [] array = new int[][]{{1,2},{3,4}};
>         System.out.println(Arrays.toString(array));
> }
>```
>这样写并不是一次性导入所有的方法，而是你用什么它就导入什么  

>___强烈不建议这么做___  
>假如你的方法是几个包共有的方法，编译器会直接报错，比如前文提到的Date类  
>![image-20250527081800667](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270818726.png)
> 解决方法：在导入类之前先说明是哪个包中的类`java.util.Date`  

### 3. 导入包中静态方法和变量  
> 格式：import static 导入，我们就以Math方法举例：
> 导入静态包之前：
> ```Java
> double ret = Math.sqrt(Math.pow(10,2)+Math.pow(15,2));
> ```
> 导入静态包之后：
> ```Java
> import static java.lang.Math.*;
> double ret =sqrt(pow(10,2)+pow(15,2));
> ```
> 我们可以看到不用再写Math方法名了，极端点，你甚至可以这样：
> ```Java
> import static java.lang.System.*;
> out.println("hello world");
> ```
> System直接省略不写了，虽然这些省略看起来方便了，但是代码可读性很低且易产生不必要的麻烦  
> 
> ___建议：该写的包名还是要写上，无论是静态的还是非静态的，都写上，不要使用“*”这个通配符，同时静态包Java会自动导入  

### 4. 如何查看方法所在包的路径  
> 在Idea中双击shift然后输入方法，点击类来查找  
> ![image-20250527083800069](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270838182.png)
> 我们可以看到System方法在Java.lang这个路径底下，我们具体来看看在哪  
> 首先找到我们安装的JDK文件夹-->lib文件夹-->将src这个压缩包解压-->java.base文件夹-->java文件夹-->lang文件夹-->找到刚刚System的Java文件  
> ![image-20250527084148284](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270841363.png)
> 其他类寻找的方法也是如此，因此我们知道类是Java封装好的直接给我们用的  

### 5. 自定义包  
* 我们经常说的在src建立一个Java文件，而src可以看到是一个文件夹，其实它就是默认包  
* 那我们可以不可以建立自己的包呢，可以的  
* 流程---->右键src，会有个新建包选项
* 这里要注意：包名一般使用公司域名倒置，比如百度就写com.baidu.www且全部小写，当然叫其他名字也不是不行
* 包建立好后再在包上建立Java文件  
* 报名要与文件路径匹配，当然Idea编译器自动帮你匹配了  
![image-20250527085105032](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270851116.png)

### 6. 包访问控制权限初识  
> 包访问控制权限指的是只有在同一个包下才可以访问（即同一个文件夹下）  
> ![image-20250527090146384](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270901676.png)
> 可以看到我在另一个包中定义了两个两个成员变量，但是我没有用public去修饰  
> **当我在其他类中想通过对象访问这个类的成员变量的时候，编译器报错，提示非public无法从外界访问**  
> * 如果你细心的话，会发现图片左边代码第一行Java自动帮我导入了我的自定义包  
> * 按道理来说左右两个包应该是链接起来了，可以看成一个包了，那为什么我还是不能通过对象修改呢  
> * **这就是包访问控制权限另一大特点：即使不同包链接起来，对于未加public修饰的成员变量**  
> * **始终只能在其所在的包中对变量进行修改和赋值**  
> *如果成员变量前面假如private修饰，就只能在当前类中对变量进行修改和赋值，权限范围变得更小*，这就是封装  

** 类只有public和非public，没有其他叫法

## 8. 封装  
隐藏对象属性和实现方法，仅保留对外接口供调用，比如一台电脑内部看不到仅保留各个按键供使用  
> 1. 将成员变量由public修饰转换为private修饰，即私有化，即使在同一个包下在其他类中也无法直接访问  
> 2. 若想在其他类中访问，可以写一个方法，一次来提供对外接口访问  
> ![image-20250527092623080](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270926384.png)

## 9. static关键字  
### 1. 静态成员变量  
* 有这么一个场景：现在我一个类创建了两个对象，比如有一个成员变量是身高  
* 假如我和你都是一米八，那我创建你和我两个对象的时候还要都说身高是一米八吗，很显然不用  
* 此时如果你将身高假如static修饰，会发现对象打印的时候都没有身高这个打印选项，那它去哪了  
![image-20250527093629157](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270936702.png)
> * 解释：成员变量被static关键字修饰后，此时成员变量创建的对象不在堆中了  
> * 而是在方法区，并且此时无论你创建多少个对象，成员变量都只有一个  
> * 此时你无法通过对象去访问了，而是要通过类名去访问`TryPlus.high`  
> ![image-20250527093925814](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270939885.png)
> * 即加了static就从**静态成员变量-->类变量**了，此时无需创建对象就可以访问对象的成员变量  
> * 换句话来说它是所有对象共有的成员变量，它跟其他类型成员变量一样
> * 不可在成员变量中再修改值，并且生命周期伴随着类的生命周期，类创建开始，类销毁结束  
> ```Java
> static double high = 180.0;
> high = 185.0;//错误示范，请别这么做
> ```

### 2. 静态成员方法  
* 这种方法可以通过类名直接调用，无需创建对象  
* 这就是之前为什么很多方法建议加上static关键字，就是为了直接调用此方法而不用再去麻烦的创建对象  
* 有几个注意事项：
> 1. 在静态成员方法内调用非静态成员方法会报错，因为非静态成员方法的调用需要创建对象，而静态成员方法本身不需要对象  
> 如何解决：直接在静态方法内new一个对象就好  
> ![image-20250527095320006](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505270953526.png)
> 2. 反之，在非静态成员方法调用静态成员方法就不需要创建对象了，因为非静态成员方法本身就创建了对象  
> 3. 在静态成员方法内，也不可直接使用非静态成员变量，原理也是需要实例化对象  
> 包括this关键字也不可以，因为静态本身不需要对象，若确实要访问new一个对象就好了  
> ___总结就是一句话：静态成员变量和静态成员方法不依赖于对象___  

## 10. 代码块  
分类：实例（构造）、静态、普通、同步  
### 1. 普通代码块  
> ```Java
> {
>     int tmp = 100;
>     System.out.println("这是普通代码块");
> }
> System.out.println(tmp);
> ```
> * 格式就是跟上面代码一样，我在普通代码块中定义了一个变量tmp  
> * 当我在这个代码块之外打印变量tmp，会报错，**原因即使代码块代表着作用域**，出作用域失效  
> * *这种代码块建议少用，非常不好看且逻辑混乱*  

### 2. 构造（实例）代码块

* 若将普通代码块放在类中，就变成构造（实例）代码块了，这些代码块在类的对象实例化时候就会被调用  
* 如果构造代码块写在初始化静态成员变量下面，且构造代码块中修改成员变量的值，那么成员变量的值机会被修改   
![image-20250527101446178](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505271014628.png)
> 若果类中有静态成员变量，构造代码块，构造方法，它们都处于同一级，那就按顺序谁在上谁就先调用  
> > 你是否有个疑问，如果我把这个构造代码块写在最前面，然后我里面直接写一个静态成员变量并赋值  
> > 我都没初始化编译器是怎么认识这个静态成员变量的  
>```Java
>{
>   System.out.println("这是构造代码块");
>   a = 100;
> }
> String name = "zlh";
> public int a = 10;
> private int age = 19;
> static double high = 180.0;
> ```
> > 这个我们后面再解释，涉及到继承多态  

### 3. 静态代码块  
```Java
static{
 System.out.println("这是静态代码块");
}
```
> 注意：1. 相比于其他代码块，它是最先被执行的，并且若类中有多个静态代码块，按顺序从上到下执行  
> ![image-20250527102534841](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505271025288.png)
> * ___并且不同种类代码块执行顺序跟在类中代码块位置无关！！！___
> 2. 静态代码块只执行一次，第二次及以后实例化对象的时候不再加载，即每个类加载一次静态代码块  
> ![image-20250527103102062](https://zlhimage.oss-cn-guangzhou.aliyuncs.com/202505271031531.png)

* 总的来说在类中各个代码块执行顺序：  
* 静态（类加载时就执行）-->构造代码块（new对象时执行）-->构造方法（new对象时执行）  

***
<center>文章内容难免有错误，欢迎各位大佬指出</center>

***
<center>本文章演示所用代码</center>
<div align = center>
<a href = https://gitee.com/pluchon/java-career/tree/master/TestProject20250525/src>Git码云仓库链接上半部分</a>
<div>

<div align = center>
<a href = https://gitee.com/pluchon/java-career/tree/master/TestProjrct20250527/src>Git码云仓库链接下半部分</a>
<div>

***
<center>END</center>